<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<title>100 Days Love Matrix</title>
<style>
  html,body{margin:0;height:100%;background:#000;overflow:hidden;font-family:Courier,monospace}
  canvas{display:block}
</style>
</head>
<body>
<canvas id="c"></canvas>
<script>
/* ===== 1. 聊天记录 ===== */
const chatHistory = [
  "2025-04-23 22:00 你说：今天算是第一天了哦",
  "2025-04-23 22:00 我说：嘿嘿，嗯呢第一天",
  "这次是牵手",
  "下次就要摸腹肌了",
  "okok",
  "2025-04-30 6:16 你说：感觉下辈子重生有可能会成为一个蛋堡",
  "我说：这辈子蛋堡吃多了哈哈哈",
  "你说下辈子也可以成为你，以后吃你不比蛋堡少",
  "2025 05-14 21:41 ",
  "想你呢,[爱心][爱心][爱心]",
  "想我还是想摸我",
  "想你呢[爱心]",
  "[呲牙]我也想摸你",
  "你想摸哪儿都行[阴险]",
  "那当然了",
  "把我摸舒服",
  "[微笑]前提是把我摸爽",
  "2025 06-18 14:10",
  "宝宝你走了我该怎么办啊",
  "我也会想你的宝宝",
  "2025 07-09 22:57 ",
  "洗完了,宝宝睡了吗",
  "还没,等你呢,其实,有点想要",
  "我也想干",
  "哈哈哈,不可以,忍",
  "嗯呐,开学猛猛干",
  "嘻嘻,想你，快睡觉",
  "再不睡我手就忍不住了",
  "想舔了,其实,[色]宝宝",
  "[害羞][害羞][害羞]",
  "梦里想你,小宝宝,嘻嘻,晚安宝宝",
  "晚安宝宝,爱你呦",
  "我也爱你"
];

/* ===== 2. 最终情话 ===== */
const finalWords = "第100天，仍无限循环：while(true){ love++; }，一直爱你天雪";
const MAX_ROWS = 5;               // 最多同时出现 5 行
let visibleLines = [];            // 当前正在显示的 5 行
let nextLineIdx = 0;              // 指向 chatHistory 的下一条


/* ===== 3. 生成明文 & 密文行 ===== */
const plainLines = chatHistory.join("\n").split("\n");
const cipherLines = plainLines.map(l => btoa(unescape(encodeURIComponent(l))));
const finalPlainLines = [finalWords];
const finalCipherLines = [btoa(unescape(encodeURIComponent(finalWords)))];
const totalRows = plainLines.length + finalPlainLines.length;

/* ===== 4. Canvas 初始化 ===== */
const cvs = document.getElementById("c");
const ctx = cvs.getContext("2d");
let W, H;
function resize(){ W=cvs.width=innerWidth; H=cvs.height=innerHeight; }
addEventListener("resize", resize); resize();

/* ===== 5. 字符雨参数 ===== */
const fontSize = 18;
const cols = Math.floor(W / fontSize);
const drops = Array(cols).fill(1);
const base64Chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
let revealCharIndex = 0;        // 已解密的字符总数
const revealSpeed = 3;          // 每帧解密字符数

/* ===== 6. 绘制函数 ===== */
function draw(){
  ctx.fillStyle="rgba(0,0,0,0.05)";
  ctx.fillRect(0,0,W,H);
  ctx.fillStyle="#0f0";
  ctx.font=fontSize+"px monospace";

  /* 上半部：随机 base64 字符雨 */
  for(let i=0;i<drops.length;i++){
    const ch = base64Chars[Math.floor(Math.random()*base64Chars.length)];
    ctx.fillText(ch, i*fontSize, drops[i]*fontSize);
    if(drops[i]*fontSize>H && Math.random()>0.975) drops[i]=0;
    drops[i]++;
  }

  /* 下半部：解密区 */
  const startY = H - totalRows*fontSize;
  let globalIdx = 0;

  /* 聊天记录 */
  /* === 循环字幕：最多 5 行 === */
const lineHeight = fontSize;
const bottomY = H - 5 * lineHeight;   // 5 行高区域

/* 1. 如果当前不足 5 行且还有记录，就补一行 */
while (visibleLines.length < MAX_ROWS && nextLineIdx < chatHistory.length) {
  visibleLines.push({
    plain: chatHistory[nextLineIdx],
    cipher: btoa(unescape(encodeURIComponent(chatHistory[nextLineIdx]))),
    revealed: 0
  });
  nextLineIdx = (nextLineIdx + 1) % chatHistory.length;   // 循环使用
}

/* 2. 逐字符解密并绘制 */
for (let r = 0; r < visibleLines.length; r++) {
  const line = visibleLines[r];
  line.revealed = Math.min(line.plain.length, line.revealed + 1); // 每帧多解 1 字符
  const txt = line.plain.slice(0, line.revealed) +
              line.cipher.slice(line.revealed);
  ctx.fillText(txt, 0, bottomY + r * lineHeight);
}

/* 3. 如果最上面一行已完全解密并停留够久，就移除它 */
if (visibleLines.length && visibleLines[0].revealed === visibleLines[0].plain.length) {
  // 停留 120 帧(≈4 秒)后顶掉；可改成任何数字
  if (++visibleLines[0].stay > 120) visibleLines.shift();
}


  /* 最终情话 */
  for(let row=0;row<finalPlainLines.length;row++){
    const y = startY + (plainLines.length + row)*fontSize;
    const plain = finalPlainLines[row];
    const cipher = finalCipherLines[row];
    const len = Math.min(plain.length, Math.max(0, revealCharIndex - globalIdx));
    const visible = plain.slice(0, len) + cipher.slice(len);
    ctx.fillText(visible, 0, y);
    globalIdx += plain.length;
  }

  /* 推进解密 */
  if(revealCharIndex < globalIdx) revealCharIndex += revealSpeed;
}

/* ===== 7. 启动 & 全屏 ===== */
setInterval(draw, 33);
addEventListener("keydown", e=>{
  if(e.key.toLowerCase()==="f"){
    document.fullscreenElement ? document.exitFullscreen()
                                 : document.documentElement.requestFullscreen();
  }
});
</script>
  <!-- 背景音乐：放在 body 末尾，自动循环，默认静音 -->
<audio id="bgm" loop preload="auto">
  <source src="bgm.mp3" type="audio/mpeg">
  你的浏览器不支持 audio 标签
</audio>

<script>
/* 允许用户点任意键开启/关闭音乐 */
const bgm = document.getElementById('bgm');
window.addEventListener('keydown', e => {
  if (e.key.toLowerCase() === 'm') {   // 按 M 键切换播放/暂停
    bgm.paused ? bgm.play() : bgm.pause();
  }
});
/* 如果希望自动播放（Chrome 需用户交互后），可以在这里 bgm.play() */
</script>

</body>
</html>


